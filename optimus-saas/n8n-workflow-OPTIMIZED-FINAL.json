{
  "name": "OPTIMIZED FINAL - AI Article Generation",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ai-article-generation",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-node",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [200, 300],
      "webhookId": "ai-article-generation"
    },
    {
      "parameters": {
        "jsCode": "// Extract and validate prompt from multiple possible locations\nconst inputData = $input.first();\nlet prompt = '';\n\n// Try all possible data locations\nif (inputData.json?.prompt) {\n  prompt = inputData.json.prompt;\n} else if (inputData.body?.prompt) {\n  prompt = inputData.body.prompt;\n} else if (inputData.json?.body?.prompt) {\n  prompt = inputData.json.body.prompt;\n} else if (inputData.query?.prompt) {\n  prompt = inputData.query.prompt;\n}\n\nconsole.log('Extracted prompt:', prompt);\nconsole.log('Prompt type:', typeof prompt);\nconsole.log('Prompt length:', prompt ? prompt.length : 0);\n\n// Validate prompt\nif (!prompt || typeof prompt !== 'string' || !prompt.trim()) {\n  return {\n    error: true,\n    message: 'Le prompt est requis et ne peut pas être vide',\n    debug: {\n      receivedData: inputData,\n      extractedPrompt: prompt,\n      promptType: typeof prompt\n    }\n  };\n}\n\n// Return clean prompt for next node\nreturn {\n  prompt: prompt.trim(),\n  error: false\n};"
      },
      "id": "extract-validate",
      "name": "Extract & Validate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [400, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.error}}",
              "value2": false
            }
          ]
        }
      },
      "id": "check-validation",
      "name": "Check Validation",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [600, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer sk-proj-WZcBJ_jPGAJJXXH5wpAU2eJ-xrmS5qcGLp8MNBGPywfaX6z_E8SJPzGc9-RlsY8GWXBNtqXSzaT3BlbkFJO8dPJfTKFDf1QABp5YdL4D0KpKG5Gfj7CQx_c1KfCzLl2Z7Q2EGqfUW1M1G2A3J9e7Y4r2QJZ"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"gpt-3.5-turbo-instruct\",\n  \"prompt\": \"Tu es un expert en rédaction d'articles marketing en français. Écris un article complet et engageant sur le sujet suivant : \\\"{{ $json.prompt }}\\\"\\n\\nL'article doit :\\n- Avoir un titre accrocheur (maximum 60 caractères)\\n- Contenir entre 500 et 1000 mots\\n- Être structuré avec des sous-titres\\n- Être optimisé SEO\\n- Être écrit dans un style professionnel mais accessible\\n- Inclure des conseils pratiques\\n\\nFormat de réponse :\\nTITRE: [Le titre de l'article]\\nCONTENU: [Le contenu complet de l'article avec sous-titres en markdown]\",\n  \"max_tokens\": 2000,\n  \"temperature\": 0.7\n}",
        "options": {
          "timeout": 25000,
          "retry": {
            "enabled": true,
            "maxRetries": 2
          }
        }
      },
      "id": "openai-request",
      "name": "OpenAI Request",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [800, 200]
    },
    {
      "parameters": {
        "jsCode": "// Process successful OpenAI response\ntry {\n  const response = $input.first().json;\n  \n  console.log('OpenAI Response received:', response);\n  \n  // Check if response has the expected structure\n  if (!response || !response.choices || !response.choices[0] || !response.choices[0].text) {\n    throw new Error('Invalid OpenAI response structure');\n  }\n  \n  const generatedText = response.choices[0].text.trim();\n  console.log('Generated text length:', generatedText.length);\n  \n  // Extract title and content using improved regex\n  const titleMatch = generatedText.match(/TITRE\\s*:\\s*(.+?)(?=\\n|$)/i);\n  const contentMatch = generatedText.match(/CONTENU\\s*:\\s*([\\s\\S]+)/i);\n  \n  let title = '';\n  let content = '';\n  \n  if (titleMatch && titleMatch[1]) {\n    title = titleMatch[1].trim();\n    // Ensure title doesn't exceed 60 characters\n    if (title.length > 60) {\n      title = title.substring(0, 57) + '...';\n    }\n  } else {\n    // Fallback: use first line as title\n    const lines = generatedText.split('\\n').filter(line => line.trim());\n    title = lines[0] ? lines[0].trim().substring(0, 60) : 'Article généré par IA';\n  }\n  \n  if (contentMatch && contentMatch[1]) {\n    content = contentMatch[1].trim();\n  } else {\n    // Fallback: use entire text as content\n    content = generatedText;\n  }\n  \n  // Clean up content (remove TITRE line if present)\n  content = content.replace(/^TITRE\\s*:\\s*.+$/gim, '').trim();\n  \n  // Calculate metrics\n  const wordCount = content.split(/\\s+/).filter(word => word.length > 0).length;\n  const characterCount = content.length;\n  \n  return {\n    success: true,\n    title: title,\n    content: content,\n    error: null,\n    timestamp: new Date().toISOString(),\n    wordCount: wordCount,\n    characterCount: characterCount,\n    debug: {\n      openaiResponse: !!response,\n      hasChoices: !!response.choices,\n      textLength: generatedText.length\n    }\n  };\n  \n} catch (error) {\n  console.error('Processing error:', error);\n  return {\n    success: false,\n    title: '',\n    content: '',\n    error: 'Erreur lors du traitement de la réponse OpenAI: ' + error.message,\n    timestamp: new Date().toISOString(),\n    debug: {\n      errorType: error.name,\n      errorMessage: error.message,\n      inputData: $input.first()\n    }\n  };\n}"
      },
      "id": "process-success",
      "name": "Process Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1000, 200]
    },
    {
      "parameters": {
        "jsCode": "// Handle validation error\nconst inputData = $input.first();\n\nreturn {\n  success: false,\n  title: '',\n  content: '',\n  error: inputData.message || 'Le prompt est requis et ne peut pas être vide',\n  timestamp: new Date().toISOString(),\n  debug: inputData.debug || {}\n};"
      },
      "id": "validation-error",
      "name": "Validation Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [800, 400]
    },
    {
      "parameters": {
        "jsCode": "// Handle OpenAI API error\nconst inputData = $input.first();\nlet errorMessage = 'Erreur lors de la génération de l\\'article';\n\nconsole.log('OpenAI Error input:', inputData);\n\n// Extract error information\nif (inputData.json?.error) {\n  const apiError = inputData.json.error;\n  errorMessage = apiError.message || apiError.type || 'Erreur API OpenAI';\n} else if (inputData.error) {\n  errorMessage = inputData.error.message || inputData.error;\n} else if (inputData.message) {\n  errorMessage = inputData.message;\n}\n\nreturn {\n  success: false,\n  title: '',\n  content: '',\n  error: 'Erreur OpenAI: ' + errorMessage,\n  timestamp: new Date().toISOString(),\n  debug: {\n    httpStatus: inputData.statusCode,\n    apiError: inputData.json?.error,\n    fullError: inputData\n  }\n};"
      },
      "id": "openai-error",
      "name": "OpenAI Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$json}}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "response-node",
      "name": "Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1200, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract & Validate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract & Validate": {
      "main": [
        [
          {
            "node": "Check Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Validation": {
      "main": [
        [
          {
            "node": "OpenAI Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validation Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Request": {
      "main": [
        [
          {
            "node": "Process Success",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "OpenAI Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Success": {
      "main": [
        [
          {
            "node": "Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation Error": {
      "main": [
        [
          {
            "node": "Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Error": {
      "main": [
        [
          {
            "node": "Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {},
  "versionId": "1"
}